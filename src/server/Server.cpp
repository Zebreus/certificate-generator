// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <string>
#include <sstream>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <fstream>
#include <filesystem>
#include <ctime>
#include "Student.hpp"
#include "TemplateCertificate.hpp"
#include "Certificate.hpp"
#include "Batch.hpp"
#include <nlohmann/json.hpp>
#include <cxxopts.hpp>

#include <thrift/concurrency/ThreadManager.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/TToString.h>

#include "gen-cpp/CertificateGenerator.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::CertificateGeneratorThrift;

json baseConfiguration;
bool keepGeneratedFiles;

class CertificateGeneratorHandler : virtual public CertificateGeneratorIf {
 private:
 string id;
 
 public:
  CertificateGeneratorHandler(string id): id(id) {
    // Your initialization goes here
    cout << "Connecting " << id << endl;
  }
  
  ~CertificateGeneratorHandler(){
	  cout << "Disconnecting " << id << endl;
  }

  void generateCertificates(std::vector<GeneratedFile> & _return, const std::string& configuration) {

		//Parse received configuration
		json batchConfiguration;
		try{
			batchConfiguration = json::parse(configuration);
		}catch(const nlohmann::detail::parse_error& error){
			InvalidConfiguration thriftError;
			thriftError.message = error.what();
			std::cerr << "Invalid json in received batch configuration: " << std::endl;
			throw thriftError;
		}
		
		//Add base configuration
		//TODO see if it wouldn't be smarter to use base configuration and just add the students
		std::stringstream outputDirectory;
		std::stringstream workingDirectory;
		outputDirectory << string(baseConfiguration["outputDirectory"].get<std::string>()) << "/" << id << "/";
		workingDirectory << baseConfiguration["workingDirectory"].get<std::string>() << "/" << id << "/";
		batchConfiguration["outputDirectory"] = outputDirectory.str();
		batchConfiguration["workingDirectory"] = workingDirectory.str();
		batchConfiguration["templates"] = baseConfiguration["templates"];
		batchConfiguration["resources"] = baseConfiguration["resources"];
		filesystem::create_directories(workingDirectory.str());
		filesystem::create_directories(outputDirectory.str());
		std::cout << "Created output directory " << outputDirectory.str() << std::endl;
		std::cout << "Created working directory " << workingDirectory.str() << std::endl;
		
		
		//Create batch
		Batch batch(batchConfiguration);
		
		//Check batch
		std::cout << "Checking Batch" << std::endl;
		if(batch.check()){
			std::cout << "Check succeeded" << std::endl;
		}else{
			std::cerr << "Check failed" << std::endl;
			InvalidConfiguration thriftError;
			thriftError.message = "Failed to check configuration";
			throw thriftError;
		}
		
		//Execute batch
		std::cout << "Executing Batch" << std::endl;
		batch.executeBatch();
		std::cout << "All done" << std::endl;
		
		//Returning results
		std::cout << "Returning result" << std::endl;
		vector<GeneratedFile> generatedFiles;
		for(string outputFile : batch.getOutputFiles() ){
			GeneratedFile file;
			file.name = filesystem::path(outputFile).filename();
			stringstream content;
			ifstream pdfFile(outputFile, ios::in | ios::binary);
			if(!pdfFile){
				InvalidConfiguration thriftError;
				thriftError.message = "Failed to open output file";
				throw thriftError;
			}
			content << pdfFile.rdbuf();
			pdfFile.close();
			file.content = content.str();
			generatedFiles.push_back(file);
		}
		
		//Removing files
		std::cout << "Cleaning files" << std::endl;
		filesystem::remove_all(workingDirectory.str());
		if(!keepGeneratedFiles){
			filesystem::remove_all(outputDirectory.str());
		}
		
		_return = generatedFiles;
  }

};

class CertificateGeneratorCloneFactory : virtual public CertificateGeneratorIfFactory {
 private:
  int count = 0;
 public:
  ~CertificateGeneratorCloneFactory() override = default;
  CertificateGeneratorIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) override
  {
    std::shared_ptr<TSocket> sock = std::dynamic_pointer_cast<TSocket>(connInfo.transport);
    std::time_t t = std::time(0);
    std::tm* now = std::localtime(&t);
    std::stringstream id;
    id << (now->tm_year%100) << "-" << std::setfill('0') << std::setw(2) << (now->tm_mon + 1) << "-" << std::setfill('0') << std::setw(2) << (now->tm_hour) << "-" << std::setfill('0') << std::setw(2) << (now->tm_min) << "-" << std::setfill('0') << std::setw(2) << (now->tm_sec) << "_" << sock->getPeerAddress() << "_" << count++;
    //cout << "Connecting " << id.str() << endl;
    return new CertificateGeneratorHandler(id.str());
  }
  void releaseHandler( CertificateGeneratorIf* handler) override {
    delete handler;
  }
};

int main(int argc, char **argv) {

	//Parse options
	string batchConfigurationFile;
	string workingDirectory;
	string outputDirectory;
	int serverPort;
	bool verbose = false;
	try{
		cxxopts::Options options(argv[0], "Certificate generator server");
		options.add_options()
			("c,configuration", "The base configuration file", cxxopts::value<string>(), "FILE")
			//("w,working-dir", "The working directory", cxxopts::value<string>(), "PATH")
			//("o,output-dir", "The output directory", cxxopts::value<string>(), "PATH")
			("p,port", "The port on which the server listens", cxxopts::value<int>())
			("k,keep-files", "Keep generated files", cxxopts::value<bool>(keepGeneratedFiles))
			("v,verbose", "Enable output", cxxopts::value<bool>(verbose))
			("help", "Print help");
		auto result = options.parse(argc, argv);
		if (result.count("help") || result.arguments().size()==0){
			cout << options.help({""}) << std::endl;
			exit(0);
		}
		if (result.count("configuration")){
			batchConfigurationFile = result["configuration"].as<string>();
		}else{
			throw cxxopts::OptionException("No base configuration file specified");
		}
		if (result.count("port")){
			serverPort = result["port"].as<int>();
			if(serverPort > 65535 || serverPort < 1){
				throw cxxopts::OptionException("Invalid port specified");
			}
		}else{
			throw cxxopts::OptionException("No port specified");
		}
	}catch (const cxxopts::OptionException& e){
		cerr << "Error parsing options: " << e.what() << endl;
		exit(1);
	}
	
	//Disable cout
	if(!verbose){
		cout.rdbuf(NULL);
	}
	
	//Load batch configuration
	std::cout << "Loading base configuration" << std::endl;
	ifstream input;
	input.open(batchConfigurationFile, ios::in);
	if(!input){
		cerr << "Error reading base configuration file" << endl;
		exit(EXIT_FAILURE);
	}
	try{
		baseConfiguration = json::parse(input);
	}catch(const nlohmann::detail::parse_error& error){
		cerr << "Invalid json in base configuration: " << batchConfigurationFile << endl;
		cerr << error.what() << endl;
		exit(EXIT_FAILURE);
	}
	input.close();
	
	//Check base configuration
	std::cout << "Checking base configuration" << std::endl;
	bool abort = true;
	for(json templateFile : baseConfiguration["templates"]){
		if(templateFile.is_string()){
			abort = false;
		}
	}
	if(abort){
		std::cerr << "Error checking configuration: No templates specified" << std::endl;
	}
	if(!baseConfiguration["outputDirectory"].is_string()){
		std::cerr << "Error checking configuration: No output directory specified" << std::endl;
		abort = true;
	}
	if(!baseConfiguration["workingDirectory"].is_string()){
		std::cerr << "Error checking configuration: No working directory specified" << std::endl;
		abort = true;
	}
	if(abort){
		exit(EXIT_FAILURE);
	}
	
	//Initialize thrift server
	std::cout << "Initializing server" << std::endl;
	int port = serverPort;
	::std::shared_ptr<CertificateGeneratorProcessorFactory> processorFactory(std::make_shared<CertificateGeneratorProcessorFactory>(std::make_shared<CertificateGeneratorCloneFactory>()));
	::std::shared_ptr<TServerTransport> serverTransport(std::make_shared<TServerSocket>(port));
	::std::shared_ptr<TTransportFactory> transportFactory(std::make_shared<TBufferedTransportFactory>());
	::std::shared_ptr<TProtocolFactory> protocolFactory(std::make_shared<TBinaryProtocolFactory>());

	//Open thrift server
	std::cout << "Starting server" << std::endl;
	TThreadedServer server(processorFactory, serverTransport, transportFactory, protocolFactory);
	server.serve();
	return 0;
}
